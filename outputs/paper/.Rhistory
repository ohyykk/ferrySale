) %>%
filter(!is.na(Year) & !is.na(Month))  # Remove rows with NA in Year or Month
# Step 2: Group the data by Year and Month and calculate total sales and redemptions per month for each year
monthly_data <- data %>%
group_by(Year, Month) %>%
summarise(
Sales.Count = sum(Sales.Count, na.rm = TRUE),
Redemption.Count = sum(Redemption.Count, na.rm = TRUE),
.groups = 'drop'  # Ungroup after summarising
)
# Step 3: Determine the maximum value for symmetrical scaling
max_count <- max(max(monthly_data$Sales.Count), max(monthly_data$Redemption.Count))
# Step 4: Define colors for each year
year_colors <- c("2015" = "#d07f7a", "2016" = "#377EB8", "2017" = "#7f9f6f",
"2018" = "#984EA3", "2019" = "#FC9272", "2020" = "#EC7014",
"2021" = "#A65628", "2022" = "#C51B7D", "2023" = "#FFD92F")
# Step 5: Create the plot with inverted Redemption Count for bottom half visualization
ggplot(monthly_data, aes(x = Month)) +
# Line plot for Redemption Count (inverted)
geom_line(aes(y = -Redemption.Count, color = as.factor(Year), group = Year), linewidth = 1.2) +
# Line plot for Sales Count (normal)
geom_line(aes(y = Sales.Count, color = as.factor(Year), group = Year), linetype = "dashed", linewidth = 1.2) +
# Set symmetrical y-axis limits for both Sales and Redemption
scale_y_continuous(limits = c(-max_count, max_count),
breaks = seq(-max_count, max_count, by = 100000),
sec.axis = sec_axis(~ -., name = "Sales Count (dashed lines)")) +
# Add plot labels
labs(
y = "Redemption Count (straight lines)",  # Y-axis for Redemption Count (inverted)
x = "Month",             # X-axis for Month
color = "Year"
) +
# Manually specify colors for each year
scale_color_manual(values = year_colors) +
# Apply minimal theme and customize axis titles
theme_minimal() +
theme(
axis.title.y.right = element_text(color = "black", size = 12, margin = margin(r = 10)),
axis.title.y.left = element_text(color = "black", size = 12, margin = margin(l = 10)),
plot.title = element_text(hjust = 0.5, size = 16),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.text.y = element_text(size = 10),
axis.ticks.y = element_blank()
)
#| label: fig-linePlot5
#| fig-cap: Redemption and Sales Counts Over Time in years
#| echo: false
# Calculate the range for both y-axes to have a symmetrical appearance
y_max <- max(max(data$Sales.Count), max(data$Redemption.Count))
# Create the plot
ggplot(data, aes(x = Timestamp)) +
# Line plot for Redemption Count
geom_line(aes(y = Redemption.Count), color = "#F7C4C1", linewidth = 1.2) +
# Line plot for Sales Count (inverted)
geom_line(aes(y = -Sales.Count), color = "#81B0B2", linewidth = 1.2) +
# Set y-axis limits symmetrically and apply the secondary axis
scale_y_continuous(limits = c(-y_max, y_max),
breaks = seq(-y_max, y_max, by = 1000),
sec.axis = sec_axis(~ -.,
name = "Sales Count",
breaks = seq(y_max, -y_max, by = -1000))) +
# Add plot labels
labs(
y = "Redemption Count",  # Y-axis for Redemption Count
x = "Timestamp"          # X-axis for Timestamp
) +
# Apply minimal theme and customize axis titles
theme_minimal() +
theme(
# Color the right-side axis title (Sales Count) to match the orange line
axis.title.y.right = element_text(color = "#F7C4C1", size = 12),
# Color the left-side axis title (Redemption Count) to match the pink line
axis.title.y.left = element_text(color = "#81B0B2", size = 12),
# Center the title and increase font size
)
#| label: fig-linePlot3
#| fig-cap: Redemption and Sales Counts Over Time in years
#| echo: false
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(lubridate)
library(gridExtra)  # To arrange plots
# Filter the data for 2021 and 2023
data_2023 <- data %>%
mutate(Timestamp = ymd_hms(Timestamp)) %>%
filter(year(Timestamp) == 2023)
data_2021 <- data %>%
mutate(Timestamp = ymd_hms(Timestamp)) %>%
filter(year(Timestamp) == 2021)
# Calculate the range for both y-axes for symmetry (using both years)
y_max <- max(max(data_2021$Sales.Count), max(data_2021$Redemption.Count),
max(data_2023$Sales.Count), max(data_2023$Redemption.Count))
# Plot for 2023
plot_2023 <- ggplot(data_2023, aes(x = Timestamp)) +
geom_line(aes(y = Redemption.Count), color = "#F7C4C1", linewidth = 1.2) +
geom_line(aes(y = -Sales.Count), color = "#81B0B2", linewidth = 1.2) +
scale_y_continuous(limits = c(-y_max, y_max), sec.axis = sec_axis(~ -., name = "Sales Count")) +
labs(y = "Redemption Count", x = "Month", title = "2023") +
theme_minimal()
# Plot for 2021
plot_2021 <- ggplot(data_2021, aes(x = Timestamp)) +
geom_line(aes(y = Redemption.Count), color = "#F7C4C1", linewidth = 1.2) +
geom_line(aes(y = -Sales.Count), color = "#81B0B2", linewidth = 1.2) +
scale_y_continuous(limits = c(-y_max, y_max), sec.axis = sec_axis(~ -., name = "Sales Count")) +
labs(y = "Redemption Count", x = "Month", title = "2021") +
theme_minimal()
# Arrange the two plots side by side
grid.arrange(plot_2021, plot_2023, ncol = 2)
#| label: fig-linePlot3
#| fig-cap: Redemption and Sales Counts Over Time in years
#| echo: false
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(lubridate)
library(gridExtra)  # To arrange plots
# Filter the data for 2021 and 2023
data_2023 <- data %>%
mutate(Timestamp = ymd_hms(Timestamp)) %>%
filter(year(Timestamp) == 2023)
data_2021 <- data %>%
mutate(Timestamp = ymd_hms(Timestamp)) %>%
filter(year(Timestamp) == 2021)
# Calculate the range for both y-axes for symmetry (using both years)
y_max <- max(max(data_2021$Sales.Count), max(data_2021$Redemption.Count),
max(data_2023$Sales.Count), max(data_2023$Redemption.Count))
# Plot for 2023
plot_2023 <- ggplot(data_2023, aes(x = Timestamp)) +
geom_line(aes(y = Redemption.Count), color = "#F7C4C1", linewidth = 1.2) +
geom_line(aes(y = -Sales.Count), color = "#81B0B2", linewidth = 1.2) +
scale_y_continuous(limits = c(-y_max, y_max), sec.axis = sec_axis(~ -., name = "Sales Count")) +
labs(y = "Redemption Count", x = "Month", title = "2023") +
theme_minimal()
# Plot for 2021
plot_2021 <- ggplot(data_2021, aes(x = Timestamp)) +
geom_line(aes(y = Redemption.Count), color = "#F7C4C1", linewidth = 1.2) +
geom_line(aes(y = -Sales.Count), color = "#81B0B2", linewidth = 1.2) +
scale_y_continuous(limits = c(-y_max, y_max), sec.axis = sec_axis(~ -., name = "Sales Count")) +
labs(y = "Redemption Count", x = "Month", title = "2021") +
theme_minimal()
# Arrange the two plots side by side
grid.arrange(plot_2021, plot_2023, ncol = 2)
#| label: fig-linePlot4
#| fig-cap: Redemption and Sales Counts Over Time in years
#| echo: false
# Calculate the range for both y-axes to have a symmetrical appearance
y_max <- max(max(data$Sales.Count), max(data$Redemption.Count))
# Create the plot
ggplot(data, aes(x = Timestamp)) +
# Line plot for Redemption Count
geom_line(aes(y = Redemption.Count), color = "#F7C4C1", linewidth = 1.2) +
# Line plot for Sales Count (inverted)
geom_line(aes(y = -Sales.Count), color = "#81B0B2", linewidth = 1.2) +
# Set y-axis limits symmetrically and apply the secondary axis
scale_y_continuous(limits = c(-y_max, y_max),
breaks = seq(-y_max, y_max, by = 1000),
sec.axis = sec_axis(~ -.,
name = "Sales Count",
breaks = seq(y_max, -y_max, by = -1000))) +
# Add plot labels
labs(
y = "Redemption Count",  # Y-axis for Redemption Count
x = "Timestamp"          # X-axis for Timestamp
) +
# Apply minimal theme and customize axis titles
theme_minimal() +
theme(
# Color the right-side axis title (Sales Count) to match the orange line
axis.title.y.right = element_text(color = "#F7C4C1", size = 12),
# Color the left-side axis title (Redemption Count) to match the pink line
axis.title.y.left = element_text(color = "#81B0B2", size = 12),
# Center the title and increase font size
)
# Load the knitr package for creating the table
library(knitr)
# Create a data frame with the information for each year
peak_day_data <- data.frame(
Year = c(2018, 2019, 2020, 2021, 2022, 2023),
Peak_Day = as.Date(c("2018-07-01", "2019-08-04", "2020-07-25", "2021-09-04", "2022-07-16", "2023-08-19")),
Total_Sales = c(49477, 42431, 10844, 26860, 43296, 41235)
)
# Create the table using kable
kable(peak_day_data,
col.names = c("Year", "Peak Day", "Total Sales"),
caption = "Table: Peak Day for Each Year Based on Total Sales",
align = "c")
# Load necessary libraries
library(dplyr)
library(lubridate)
# Convert the Timestamp column to proper datetime format
data <- data %>%
mutate(Timestamp = ymd_hms(Timestamp))  # Ensure proper datetime format
# Step 1: Group by Year, Day and calculate the total sales for each day
daily_sales <- data %>%
mutate(Year = year(Timestamp), Day = date(Timestamp)) %>%  # Extract Year and Day
group_by(Year, Day) %>%
summarise(Total_Sales = sum(Sales.Count, na.rm = TRUE)) %>%
ungroup()
# Step 2: Find the peak sales day for each year
peak_day_per_year <- daily_sales %>%
group_by(Year) %>%
slice_max(order_by = Total_Sales, n = 1) %>%  # Find the day with maximum sales for each year
ungroup()
# Step 3: Display the result as a table
peak_day_per_year_table <- peak_day_per_year %>%
select(Year, Peak_Day = Day, Total_Sales)
# Print the table
peak_day_per_year_table
# Load necessary libraries
library(dplyr)
library(lubridate)
library(knitr)
# Convert Timestamp column to proper datetime format
data <- data %>%
mutate(Timestamp = ymd_hms(Timestamp))
# Group data by Year, find the day with maximum Sales for each year
peak_day_per_year_table <- data %>%
mutate(Year = year(Timestamp)) %>%
group_by(Year, Date = as.Date(Timestamp)) %>%
summarise(Total_Sales = sum(Sales.Count, na.rm = TRUE)) %>%
ungroup() %>%
group_by(Year) %>%
slice_max(order_by = Total_Sales, n = 1) %>%
select(Year, Peak_Day = Date, Total_Sales)
# Display the table using knitr::kable
kable(peak_day_per_year_table, col.names = c("Year", "Peak Day", "Total Sales"),
caption = "Table: Peak Day for Each Year Based on Total Sales")
#| label: tbl-pick_day
#| echo: false
#| results: 'asis'
# Load necessary libraries
library(dplyr)
library(lubridate)
library(knitr)
# Convert Timestamp column to proper datetime format
data <- data %>%
mutate(Timestamp = ymd_hms(Timestamp))
# Group data by Year, find the day with maximum Sales for each year
peak_day_per_year_table <- data %>%
mutate(Year = year(Timestamp)) %>%
group_by(Year, Date = as.Date(Timestamp)) %>%
summarise(Total_Sales = sum(Sales.Count, na.rm = TRUE)) %>%
ungroup() %>%
group_by(Year) %>%
slice_max(order_by = Total_Sales, n = 1) %>%
select(Year, Peak_Day = Date, Total_Sales)
# Display the table using knitr::kable
kable(peak_day_per_year_table, col.names = c("Year", "Peak Day", "Total Sales"),
caption = "Table: Peak Day for Each Year Based on Total Sales")
#| label: fig-linePlot1
#| fig-cap: Redemption and Sales Counts Over Time in days
#| echo: false
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(lubridate)
# Assuming 'data' has columns: 'Timestamp' and 'Sales.Count'
# Convert Timestamp column to proper datetime format and filter out NA values
data <- data %>%
mutate(
Timestamp = ymd_hms(Timestamp),   # Convert to datetime format
Year = year(Timestamp),           # Extract Year
Month = month(Timestamp, label = TRUE, abbr = TRUE),  # Extract Month (abbreviated)
Day = day(Timestamp)              # Extract Day
) %>%
filter(!is.na(Year) & !is.na(Month))  # Remove rows with NA in Year or Month
# Group the data by Year, Month, and Day, and calculate the total sales per day for each year
daily_data <- data %>%
group_by(Year, Month, Day) %>%
summarise(
Total_Sales = sum(Sales.Count, na.rm = TRUE),
.groups = 'drop'  # Ungroup after summarising
)
# Find the peak sales day for each year
peak_day_data <- daily_data %>%
group_by(Year) %>%
filter(Total_Sales == max(Total_Sales)) %>%
ungroup()
# Step 4: Define colors for each year
year_colors <- c("2015" = "#d07f7a", "2016" = "#377EB8", "2017" = "#7f9f6f",
"2018" = "#984EA3", "2019" = "#FC9272", "2020" = "#EC7014",
"2021" = "#A65628", "2022" = "#C51B7D", "2023" = "#FFD92F")
# Create the plot
ggplot(peak_day_data, aes(x = Month, y = Total_Sales, group = Year, color = as.factor(Year))) +
geom_line(size = 1.2) +   # Line plot for each year’s peak day
geom_point(size = 3) +    # Add points for peak days
# Set y-axis label and title
labs(
title = "Peak Sales Day Analysis by Year",
x = "Month",
y = "Total Sales Count",
color = "Year"
) +
# Manually specify colors for each year
scale_color_manual(values = year_colors) +
# Apply minimal theme and customize axis titles
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 16),
axis.title.x = element_text(size = 12),
axis.title.y = element_text(size = 12),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for better readability
)
#| label: fig-linePlot1
#| fig-cap: Redemption and Sales Counts Over Time in days
#| echo: false
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(lubridate)
# Assuming 'data' has columns: 'Timestamp' and 'Sales.Count'
# Convert Timestamp column to proper datetime format and filter out NA values
data <- data %>%
mutate(
Timestamp = ymd_hms(Timestamp),   # Convert to datetime format
Year = year(Timestamp),           # Extract Year
Month = month(Timestamp, label = TRUE, abbr = TRUE),  # Extract Month (abbreviated)
Day = day(Timestamp)              # Extract Day
) %>%
filter(!is.na(Year) & !is.na(Month))  # Remove rows with NA in Year or Month
# Group the data by Year, Month, and Day, and calculate the total sales per day for each year
daily_data <- data %>%
group_by(Year, Month, Day) %>%
summarise(
Total_Sales = sum(Sales.Count, na.rm = TRUE),
.groups = 'drop'  # Ungroup after summarising
)
# Find the peak sales day for each year
peak_day_data <- daily_data %>%
group_by(Year) %>%
filter(Total_Sales == max(Total_Sales)) %>%
ungroup()
# Step 4: Define colors for each year
year_colors <- c("2015" = "#d07f7a", "2016" = "#377EB8", "2017" = "#7f9f6f",
"2018" = "#984EA3", "2019" = "#FC9272", "2020" = "#EC7014",
"2021" = "#A65628", "2022" = "#C51B7D", "2023" = "#FFD92F")
# Create the plot
ggplot(peak_day_data, aes(x = Month, y = Total_Sales, group = Year, color = as.factor(Year))) +
geom_line(size = 1.2) +   # Line plot for each year’s peak day
geom_point(size = 3) +    # Add points for peak days
# Set y-axis label and title
labs(
x = "Month",
y = "Total Sales Count",
color = "Year"
) +
# Manually specify colors for each year
scale_color_manual(values = year_colors) +
# Apply minimal theme and customize axis titles
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 16),
axis.title.x = element_text(size = 12),
axis.title.y = element_text(size = 12),
legend.title = element_text(size = 12),
legend.text = element_text(size = 10),
axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels for better readability
)
#| label: tbl-peak_day
#| echo: false
#| results: 'asis'
# Load necessary libraries
library(dplyr)
library(lubridate)
library(knitr)
# Convert Timestamp column to proper datetime format
data <- data %>%
mutate(Timestamp = ymd_hms(Timestamp))
# Group data by Year, find the day with maximum Sales for each year
peak_day_per_year_table <- data %>%
mutate(Year = year(Timestamp)) %>%
group_by(Year, Date = as.Date(Timestamp)) %>%
summarise(Total_Sales = sum(Sales.Count, na.rm = TRUE)) %>%
ungroup() %>%
group_by(Year) %>%
slice_max(order_by = Total_Sales, n = 1) %>%
select(Year, Peak_Day = Date, Total_Sales)
# Display the table using knitr::kable
kable(peak_day_per_year_table, col.names = c("Year", "Peak Day", "Total Sales"),
caption = "Table: Peak Day for Each Year Based on Total Sales")
#| label: tbl-peak_day
#| echo: false
#| results: 'asis'
# Load necessary libraries
library(dplyr)
library(lubridate)
library(knitr)
# Convert Timestamp column to proper datetime format
data <- data %>%
mutate(Timestamp = ymd_hms(Timestamp))
# Group data by Year, find the day with maximum Sales for each year
peak_day_per_year_table <- data %>%
mutate(Year = year(Timestamp)) %>%
group_by(Year, Date = as.Date(Timestamp)) %>%
summarise(Total_Sales = sum(Sales.Count, na.rm = TRUE)) %>%
ungroup() %>%
group_by(Year) %>%
slice_max(order_by = Total_Sales, n = 1) %>%
select(Year, Peak_Day = Date, Total_Sales)
# Display the table using knitr::kable
kable(peak_day_per_year_table, col.names = c("Year", "Peak Day", "Total Sales"),
caption = "Table: Peak Day for Each Year Based on Total Sales")
#| label: tbl-peak_day
#| echo: false
#| results: 'asis'
#| warning: false
#| message: false
#| error: false
# Load necessary libraries
library(dplyr)
library(lubridate)
library(knitr)
# Convert Timestamp column to proper datetime format
data <- data %>%
mutate(Timestamp = ymd_hms(Timestamp))
# Group data by Year, find the day with maximum Sales for each year
peak_day_per_year_table <- data %>%
mutate(Year = year(Timestamp)) %>%
group_by(Year, Date = as.Date(Timestamp)) %>%
summarise(Total_Sales = sum(Sales.Count, na.rm = TRUE)) %>%
ungroup() %>%
group_by(Year) %>%
slice_max(order_by = Total_Sales, n = 1) %>%
select(Year, Peak_Day = Date, Total_Sales)
# Display the table using knitr::kable
kable(peak_day_per_year_table, col.names = c("Year", "Peak Day", "Total Sales"),
caption = "Table: Peak Day for Each Year Based on Total Sales")
#| label: tbl-peak_day
#| echo: false
#| results: 'asis'
#| warning: false
#| message: false
#| error: false
# Load necessary libraries
library(dplyr)
library(lubridate)
library(knitr)
# Convert Timestamp column to proper datetime format
data <- data %>%
mutate(Timestamp = ymd_hms(Timestamp))
# Group data by Year, find the day with maximum Sales for each year
peak_day_per_year_table <- data %>%
mutate(Year = year(Timestamp)) %>%
group_by(Year, Date = as.Date(Timestamp)) %>%
summarise(Total_Sales = sum(Sales.Count, na.rm = TRUE)) %>%
ungroup() %>%
group_by(Year) %>%
slice_max(order_by = Total_Sales, n = 1) %>%
select(Year, Peak_Day = Date, Total_Sales)
# Display the table using knitr::kable
kable(peak_day_per_year_table, col.names = c("Year", "Peak Day", "Total Sales"),
caption = "Table: Peak Day for Each Year Based on Total Sales")
#| label: fig-linePlot4
#| fig-cap: Redemption and Sales Counts Over Time in years
#| echo: false
# Calculate the range for both y-axes to have a symmetrical appearance
y_max <- max(max(data$Sales.Count), max(data$Redemption.Count))
# Create the plot
ggplot(data, aes(x = Timestamp)) +
# Line plot for Redemption Count
geom_line(aes(y = Redemption.Count), color = "#F7C4C1", linewidth = 1.2) +
# Line plot for Sales Count (inverted)
geom_line(aes(y = -Sales.Count), color = "#81B0B2", linewidth = 1.2) +
# Set y-axis limits symmetrically and apply the secondary axis
scale_y_continuous(limits = c(-y_max, y_max),
breaks = seq(-y_max, y_max, by = 1000),
sec.axis = sec_axis(~ -.,
name = "Sales Count",
breaks = seq(y_max, -y_max, by = -1000))) +
# Add plot labels
labs(
y = "Redemption Count",  # Y-axis for Redemption Count
x = "Timestamp"          # X-axis for Timestamp
) +
# Apply minimal theme and customize axis titles
theme_minimal() +
theme(
# Color the right-side axis title (Sales Count) to match the orange line
axis.title.y.right = element_text(color = "#F7C4C1", size = 12),
# Color the left-side axis title (Redemption Count) to match the pink line
axis.title.y.left = element_text(color = "#81B0B2", size = 12),
# Center the title and increase font size
)
#| label: tbl-peak_day
#| echo: false
#| results: 'asis'
#| warning: false
#| message: false
#| error: false
# Load necessary libraries
library(dplyr)
library(lubridate)
library(knitr)
# Convert Timestamp column to proper datetime format
data <- data %>%
mutate(Timestamp = ymd_hms(Timestamp))
# Group data by Year, find the day with maximum Sales for each year
peak_day_per_year_table <- data %>%
mutate(Year = year(Timestamp)) %>%
group_by(Year, Date = as.Date(Timestamp)) %>%
summarise(Total_Sales = sum(Sales.Count, na.rm = TRUE)) %>%
ungroup() %>%
group_by(Year) %>%
slice_max(order_by = Total_Sales, n = 1) %>%
select(Year, Peak_Day = Date, Total_Sales)
# Display the table using knitr::kable
kable(peak_day_per_year_table, col.names = c("Year", "Peak Day", "Total Sales"),
caption = "Table: Peak Day for Each Year Based on Total Sales")
